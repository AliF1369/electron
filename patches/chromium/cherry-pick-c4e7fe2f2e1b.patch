From c4e7fe2f2e1b2e36972f1daa4d4a95cb50498eb6 Mon Sep 17 00:00:00 2001
From: Daniel Cheng <dcheng@chromium.org>
Date: Sat, 12 Nov 2022 00:27:56 +0000
Subject: [PATCH] [mojo] Validate that a message is allowed to use the sync flag.

This changes consists of several coordinated changes:
- The C++ bindings generator now emits an array of method ordinals that
  are allowed to use sync calls, but only if any method has a [Sync]
  annotation. This is intended to minimize the code cost to interfaces
  that do not have any sync methods (i.e. most of them).
- The C++ binding endpoints (mojo::Receiver, et cetera) now plumb the
  array of sync-allowed ordinals to the InterfaceEndpointClient.
- Processing an incoming message checks if the incoming message is
  allowed to use the sync flag by filtering it against the array of
  sync-allowed ordinals that was previously passed to the
  InterfaceEndpointClient.

This also fixes an incorrect forward declaration of ValidationContext in
the generated bindings that discovered in the process of writing the
test.

(cherry picked from commit 4365dddb49847a422bce674383b4aa4f38ff9e89)

Bug: 1376099
Change-Id: Icb5864dcab96ccd18c98b4cc6ade7cdef39e209f
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/3994146
Reviewed-by: Ken Rockot <rockot@google.com>
Commit-Queue: Daniel Cheng <dcheng@chromium.org>
Cr-Original-Commit-Position: refs/heads/main@{#1067894}
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4018151
Auto-Submit: Daniel Cheng <dcheng@chromium.org>
Commit-Queue: Ken Rockot <rockot@google.com>
Cr-Commit-Position: refs/branch-heads/5359@{#774}
Cr-Branched-From: 27d3765d341b09369006d030f83f582a29eb57ae-refs/heads/main@{#1058933}
---

diff --git a/mojo/public/cpp/bindings/BUILD.gn b/mojo/public/cpp/bindings/BUILD.gn
index e0cadc7..c080f1a 100644
--- a/mojo/public/cpp/bindings/BUILD.gn
+++ b/mojo/public/cpp/bindings/BUILD.gn
@@ -184,6 +184,7 @@
     "lib/sync_event_watcher.cc",
     "lib/sync_handle_registry.cc",
     "lib/sync_handle_watcher.cc",
+    "lib/sync_method_traits.h",
     "lib/task_runner_helper.cc",
     "lib/task_runner_helper.h",
     "lib/thread_safe_forwarder_base.cc",
diff --git a/mojo/public/cpp/bindings/associated_receiver.h b/mojo/public/cpp/bindings/associated_receiver.h
index d6e00d1..bf17313 100644
--- a/mojo/public/cpp/bindings/associated_receiver.h
+++ b/mojo/public/cpp/bindings/associated_receiver.h
@@ -5,15 +5,19 @@
 #ifndef MOJO_PUBLIC_CPP_BINDINGS_ASSOCIATED_RECEIVER_H_
 #define MOJO_PUBLIC_CPP_BINDINGS_ASSOCIATED_RECEIVER_H_
 
+#include <stdint.h>
+
 #include <memory>
 #include <utility>
 
 #include "base/check.h"
+#include "base/containers/span.h"
 #include "base/memory/ptr_util.h"
 #include "base/memory/scoped_refptr.h"
 #include "base/memory/weak_ptr.h"
 #include "base/strings/string_piece.h"
 #include "base/task/sequenced_task_runner.h"
+#include "mojo/public/cpp/bindings/lib/sync_method_traits.h"
 #include "mojo/public/cpp/bindings/pending_associated_receiver.h"
 #include "mojo/public/cpp/bindings/pending_associated_remote.h"
 #include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"
@@ -60,7 +64,7 @@
   void BindImpl(ScopedInterfaceEndpointHandle handle,
                 MessageReceiverWithResponderStatus* receiver,
                 std::unique_ptr<MessageReceiver> payload_validator,
-                bool expect_sync_requests,
+                base::span<const uint32_t> sync_method_ordinals,
                 scoped_refptr<base::SequencedTaskRunner> runner,
                 uint32_t interface_version,
                 const char* interface_name,
@@ -203,8 +207,8 @@
     if (pending_receiver) {
       BindImpl(pending_receiver.PassHandle(), &stub_,
                base::WrapUnique(new typename Interface::RequestValidator_()),
-               Interface::HasSyncMethods_, std::move(task_runner),
-               Interface::Version_, Interface::Name_,
+               internal::SyncMethodTraits<Interface>::GetOrdinals(),
+               std::move(task_runner), Interface::Version_, Interface::Name_,
                Interface::MessageToMethodInfo_,
                Interface::MessageToMethodName_);
     } else {
diff --git a/mojo/public/cpp/bindings/interface_endpoint_client.h b/mojo/public/cpp/bindings/interface_endpoint_client.h
index a0fe041..773a618 100644
--- a/mojo/public/cpp/bindings/interface_endpoint_client.h
+++ b/mojo/public/cpp/bindings/interface_endpoint_client.h
@@ -13,6 +13,7 @@
 
 #include "base/callback.h"
 #include "base/component_export.h"
+#include "base/containers/span.h"
 #include "base/dcheck_is_on.h"
 #include "base/location.h"
 #include "base/memory/raw_ptr.h"
@@ -56,7 +57,7 @@
   InterfaceEndpointClient(ScopedInterfaceEndpointHandle handle,
                           MessageReceiverWithResponderStatus* receiver,
                           std::unique_ptr<MessageReceiver> payload_validator,
-                          bool expect_sync_requests,
+                          base::span<const uint32_t> sync_method_ordinals,
                           scoped_refptr<base::SequencedTaskRunner> task_runner,
                           uint32_t interface_version,
                           const char* interface_name,
@@ -220,6 +221,10 @@
   // The router lock must be held when calling this.
   void ForgetAsyncRequest(uint64_t request_id);
 
+  base::span<const uint32_t> sync_method_ordinals() const {
+    return sync_method_ordinals_;
+  }
+
  private:
   struct PendingAsyncResponse {
    public:
@@ -281,7 +286,7 @@
 
   bool HandleValidatedMessage(Message* message);
 
-  const bool expect_sync_requests_ = false;
+  const base::span<const uint32_t> sync_method_ordinals_;
 
   // The callback to invoke when our peer endpoint sends us NotifyIdle and we
   // have no outstanding unacked messages. If null, no callback has been set and
diff --git a/mojo/public/cpp/bindings/lib/associated_interface_ptr_state.cc b/mojo/public/cpp/bindings/lib/associated_interface_ptr_state.cc
index 691b9cff..87519129 100644
--- a/mojo/public/cpp/bindings/lib/associated_interface_ptr_state.cc
+++ b/mojo/public/cpp/bindings/lib/associated_interface_ptr_state.cc
@@ -4,6 +4,11 @@
 
 #include "mojo/public/cpp/bindings/lib/associated_interface_ptr_state.h"
 
+#include <stdint.h>
+
+#include <utility>
+
+#include "base/containers/span.h"
 #include "mojo/public/cpp/bindings/lib/task_runner_helper.h"
 
 namespace mojo {
@@ -70,7 +75,8 @@
   // The version is only queried from the client so the value passed here
   // will not be used.
   endpoint_client_ = std::make_unique<InterfaceEndpointClient>(
-      std::move(handle), nullptr, std::move(validator), false,
+      std::move(handle), nullptr, std::move(validator),
+      /*sync_method_ordinals=*/base::span<const uint32_t>(),
       GetTaskRunnerToUseFromUserProvidedTaskRunner(std::move(runner)), 0u,
       interface_name, method_info_callback, method_name_callback);
 }
diff --git a/mojo/public/cpp/bindings/lib/associated_interface_ptr_state.h b/mojo/public/cpp/bindings/lib/associated_interface_ptr_state.h
index 418192d..578ed7b 100644
--- a/mojo/public/cpp/bindings/lib/associated_interface_ptr_state.h
+++ b/mojo/public/cpp/bindings/lib/associated_interface_ptr_state.h
@@ -141,6 +141,10 @@
     return info;
   }
 
+  InterfaceEndpointClient* endpoint_client_for_test() {
+    return endpoint_client();
+  }
+
  private:
   std::unique_ptr<Proxy> proxy_;
 };
diff --git a/mojo/public/cpp/bindings/lib/associated_receiver.cc b/mojo/public/cpp/bindings/lib/associated_receiver.cc
index d70409e..cb8a82b 100644
--- a/mojo/public/cpp/bindings/lib/associated_receiver.cc
+++ b/mojo/public/cpp/bindings/lib/associated_receiver.cc
@@ -64,7 +64,7 @@
     ScopedInterfaceEndpointHandle handle,
     MessageReceiverWithResponderStatus* receiver,
     std::unique_ptr<MessageReceiver> payload_validator,
-    bool expect_sync_requests,
+    base::span<const uint32_t> sync_method_ordinals,
     scoped_refptr<base::SequencedTaskRunner> runner,
     uint32_t interface_version,
     const char* interface_name,
@@ -74,7 +74,7 @@
 
   endpoint_client_ = std::make_unique<InterfaceEndpointClient>(
       std::move(handle), receiver, std::move(payload_validator),
-      expect_sync_requests,
+      sync_method_ordinals,
       internal::GetTaskRunnerToUseFromUserProvidedTaskRunner(std::move(runner)),
       interface_version, interface_name, method_info_callback,
       method_name_callback);
diff --git a/mojo/public/cpp/bindings/lib/binding_state.cc b/mojo/public/cpp/bindings/lib/binding_state.cc
index b1a0f39..9a004f1 100644
--- a/mojo/public/cpp/bindings/lib/binding_state.cc
+++ b/mojo/public/cpp/bindings/lib/binding_state.cc
@@ -107,7 +107,7 @@
     const char* interface_name,
     std::unique_ptr<MessageReceiver> request_validator,
     bool passes_associated_kinds,
-    bool has_sync_methods,
+    base::span<const uint32_t> sync_method_ordinals,
     MessageReceiverWithResponderStatus* stub,
     uint32_t interface_version,
     MessageToMethodInfoCallback method_info_callback,
@@ -121,7 +121,7 @@
   MultiplexRouter::Config config =
       passes_associated_kinds
           ? MultiplexRouter::MULTI_INTERFACE
-          : (has_sync_methods
+          : (!sync_method_ordinals.empty()
                  ? MultiplexRouter::SINGLE_INTERFACE_WITH_SYNC_METHODS
                  : MultiplexRouter::SINGLE_INTERFACE);
   router_ = MultiplexRouter::CreateAndStartReceiving(
@@ -131,7 +131,7 @@
 
   endpoint_client_ = std::make_unique<InterfaceEndpointClient>(
       router_->CreateLocalEndpointHandle(kPrimaryInterfaceId), stub,
-      std::move(request_validator), has_sync_methods,
+      std::move(request_validator), sync_method_ordinals,
       std::move(sequenced_runner), interface_version, interface_name,
       method_info_callback, method_name_callback);
   endpoint_client_->SetIdleTrackingEnabledCallback(
diff --git a/mojo/public/cpp/bindings/lib/binding_state.h b/mojo/public/cpp/bindings/lib/binding_state.h
index 34cba79..4e301c8 100644
--- a/mojo/public/cpp/bindings/lib/binding_state.h
+++ b/mojo/public/cpp/bindings/lib/binding_state.h
@@ -5,6 +5,8 @@
 #ifndef MOJO_PUBLIC_CPP_BINDINGS_LIB_BINDING_STATE_H_
 #define MOJO_PUBLIC_CPP_BINDINGS_LIB_BINDING_STATE_H_
 
+#include <stdint.h>
+
 #include <memory>
 #include <utility>
 
@@ -12,6 +14,7 @@
 #include "base/callback.h"
 #include "base/check.h"
 #include "base/component_export.h"
+#include "base/containers/span.h"
 #include "base/memory/ptr_util.h"
 #include "base/memory/ref_counted.h"
 #include "base/strings/string_piece.h"
@@ -23,6 +26,7 @@
 #include "mojo/public/cpp/bindings/interface_id.h"
 #include "mojo/public/cpp/bindings/lib/multiplex_router.h"
 #include "mojo/public/cpp/bindings/lib/pending_receiver_state.h"
+#include "mojo/public/cpp/bindings/lib/sync_method_traits.h"
 #include "mojo/public/cpp/bindings/message_header_validator.h"
 #include "mojo/public/cpp/bindings/pending_flush.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
@@ -89,7 +93,7 @@
                     const char* interface_name,
                     std::unique_ptr<MessageReceiver> request_validator,
                     bool passes_associated_kinds,
-                    bool has_sync_methods,
+                    base::span<const uint32_t> sync_method_ordinals,
                     MessageReceiverWithResponderStatus* stub,
                     uint32_t interface_version,
                     MessageToMethodInfoCallback method_info_callback,
@@ -120,9 +124,9 @@
     BindingStateBase::BindInternal(
         std::move(receiver_state), runner, Interface::Name_,
         std::make_unique<typename Interface::RequestValidator_>(),
-        Interface::PassesAssociatedKinds_, Interface::HasSyncMethods_, &stub_,
-        Interface::Version_, Interface::MessageToMethodInfo_,
-        Interface::MessageToMethodName_);
+        Interface::PassesAssociatedKinds_,
+        SyncMethodTraits<Interface>::GetOrdinals(), &stub_, Interface::Version_,
+        Interface::MessageToMethodInfo_, Interface::MessageToMethodName_);
   }
 
   PendingReceiver<Interface> Unbind() {
diff --git a/mojo/public/cpp/bindings/lib/interface_endpoint_client.cc b/mojo/public/cpp/bindings/lib/interface_endpoint_client.cc
index 2c63173..0bbd670 100644
--- a/mojo/public/cpp/bindings/lib/interface_endpoint_client.cc
+++ b/mojo/public/cpp/bindings/lib/interface_endpoint_client.cc
@@ -442,13 +442,13 @@
     ScopedInterfaceEndpointHandle handle,
     MessageReceiverWithResponderStatus* receiver,
     std::unique_ptr<MessageReceiver> payload_validator,
-    bool expect_sync_requests,
+    base::span<const uint32_t> sync_method_ordinals,
     scoped_refptr<base::SequencedTaskRunner> task_runner,
     uint32_t interface_version,
     const char* interface_name,
     MessageToMethodInfoCallback method_info_callback,
     MessageToMethodNameCallback method_name_callback)
-    : expect_sync_requests_(expect_sync_requests),
+    : sync_method_ordinals_(sync_method_ordinals),
       handle_(std::move(handle)),
       incoming_receiver_(receiver),
       dispatcher_(&thunk_),
@@ -858,7 +858,8 @@
 
   controller_ = handle_.group_controller()->AttachEndpointClient(handle_, this,
                                                                  task_runner_);
-  if (expect_sync_requests_ && task_runner_->RunsTasksInCurrentSequence())
+  if (!sync_method_ordinals_.empty() &&
+      task_runner_->RunsTasksInCurrentSequence())
     controller_->AllowWokenUpBySyncWatchOnSameThread();
 }
 
diff --git a/mojo/public/cpp/bindings/lib/interface_ptr_state.cc b/mojo/public/cpp/bindings/lib/interface_ptr_state.cc
index 44eba6a..843685f 100644
--- a/mojo/public/cpp/bindings/lib/interface_ptr_state.cc
+++ b/mojo/public/cpp/bindings/lib/interface_ptr_state.cc
@@ -4,6 +4,11 @@
 
 #include "mojo/public/cpp/bindings/lib/interface_ptr_state.h"
 
+#include <stdint.h>
+
+#include <utility>
+
+#include "base/containers/span.h"
 #include "mojo/public/cpp/bindings/lib/task_runner_helper.h"
 
 namespace mojo {
@@ -100,7 +105,9 @@
                                     interface_name);
   endpoint_client_ = std::make_unique<InterfaceEndpointClient>(
       router_->CreateLocalEndpointHandle(kPrimaryInterfaceId), nullptr,
-      std::move(payload_validator), false, std::move(runner_),
+      std::move(payload_validator),
+      /* sync_method_ordinals= */ base::span<const uint32_t>(),
+      std::move(runner_),
       // The version is only queried from the client so the value passed here
       // will not be used.
       0u, interface_name, method_info_callback, method_name_callback);
diff --git a/mojo/public/cpp/bindings/lib/interface_ptr_state.h b/mojo/public/cpp/bindings/lib/interface_ptr_state.h
index b3759d6..bee7a8d 100644
--- a/mojo/public/cpp/bindings/lib/interface_ptr_state.h
+++ b/mojo/public/cpp/bindings/lib/interface_ptr_state.h
@@ -25,6 +25,7 @@
 #include "mojo/public/cpp/bindings/interface_endpoint_client.h"
 #include "mojo/public/cpp/bindings/lib/multiplex_router.h"
 #include "mojo/public/cpp/bindings/lib/pending_remote_state.h"
+#include "mojo/public/cpp/bindings/lib/sync_method_traits.h"
 #include "mojo/public/cpp/bindings/pending_flush.h"
 #include "mojo/public/cpp/bindings/thread_safe_proxy.h"
 #include "mojo/public/cpp/system/message_pipe.h"
@@ -249,6 +250,10 @@
     endpoint_client()->RaiseError();
   }
 
+  InterfaceEndpointClient* endpoint_client_for_test() {
+    return endpoint_client();
+  }
+
  private:
   void ConfigureProxyIfNecessary() {
     // The proxy has been configured.
@@ -259,7 +264,8 @@
     }
 
     if (InitializeEndpointClient(
-            Interface::PassesAssociatedKinds_, Interface::HasSyncMethods_,
+            Interface::PassesAssociatedKinds_,
+            !SyncMethodTraits<Interface>::GetOrdinals().empty(),
             Interface::HasUninterruptableMethods_,
             std::make_unique<typename Interface::ResponseValidator_>(),
             Interface::Name_, Interface::MessageToMethodInfo_,
diff --git a/mojo/public/cpp/bindings/lib/multiplex_router.cc b/mojo/public/cpp/bindings/lib/multiplex_router.cc
index 9250dd3..d8dd91b 100644
--- a/mojo/public/cpp/bindings/lib/multiplex_router.cc
+++ b/mojo/public/cpp/bindings/lib/multiplex_router.cc
@@ -1067,6 +1067,12 @@
 
   bool can_direct_call;
   if (message->has_flag(Message::kFlagIsSync)) {
+    if (!message->has_flag(Message::kFlagIsResponse) &&
+        !base::Contains(endpoint->client()->sync_method_ordinals(),
+                        message->name())) {
+      RaiseErrorInNonTestingMode();
+      return true;
+    }
     can_direct_call = client_call_behavior != NO_DIRECT_CLIENT_CALLS &&
                       endpoint->task_runner()->RunsTasksInCurrentSequence();
   } else {
diff --git a/mojo/public/cpp/bindings/lib/sync_method_traits.h b/mojo/public/cpp/bindings/lib/sync_method_traits.h
new file mode 100644
index 0000000..2b334f8d
--- /dev/null
+++ b/mojo/public/cpp/bindings/lib/sync_method_traits.h
@@ -0,0 +1,31 @@
+// Copyright 2022 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MOJO_PUBLIC_CPP_BINDINGS_LIB_SYNC_METHOD_TRAITS_H_
+#define MOJO_PUBLIC_CPP_BINDINGS_LIB_SYNC_METHOD_TRAITS_H_
+
+#include <stdint.h>
+
+#include <type_traits>
+
+#include "base/containers/span.h"
+
+namespace mojo::internal {
+
+template <typename Interface, typename SFINAE = void>
+struct SyncMethodTraits {
+  static constexpr base::span<const uint32_t> GetOrdinals() { return {}; }
+};
+
+template <typename Interface>
+struct SyncMethodTraits<Interface,
+                        std::void_t<decltype(Interface::kSyncMethodOrdinals)>> {
+  static constexpr base::span<const uint32_t> GetOrdinals() {
+    return Interface::kSyncMethodOrdinals;
+  }
+};
+
+}  // namespace mojo::internal
+
+#endif  // MOJO_PUBLIC_CPP_BINDINGS_LIB_SYNC_METHOD_TRAITS_H_
diff --git a/mojo/public/cpp/bindings/tests/BUILD.gn b/mojo/public/cpp/bindings/tests/BUILD.gn
index 1f68365..e7f1bfa 100644
--- a/mojo/public/cpp/bindings/tests/BUILD.gn
+++ b/mojo/public/cpp/bindings/tests/BUILD.gn
@@ -66,6 +66,7 @@
     ":mojo_public_bindings_test_utils",
     ":test_extra_cpp_template_mojom",
     ":test_mojom",
+    ":test_mojom__generate_message_ids",
     "//base/test:test_support",
     "//mojo/core/test:test_support",
     "//mojo/public/cpp/bindings",
diff --git a/mojo/public/cpp/bindings/tests/bindings_perftest.cc b/mojo/public/cpp/bindings/tests/bindings_perftest.cc
index d208bfd9..ac29ef6 100644
--- a/mojo/public/cpp/bindings/tests/bindings_perftest.cc
+++ b/mojo/public/cpp/bindings/tests/bindings_perftest.cc
@@ -212,12 +212,12 @@
 
   InterfaceEndpointClient client0(
       router0->CreateLocalEndpointHandle(kPrimaryInterfaceId), &paddle0,
-      nullptr, false, base::ThreadTaskRunnerHandle::Get(), 0u,
-      kTestInterfaceName, MessageToMethodInfo, MessageToMethodName);
+      nullptr, {}, base::ThreadTaskRunnerHandle::Get(), 0u, kTestInterfaceName,
+      MessageToMethodInfo, MessageToMethodName);
   InterfaceEndpointClient client1(
       router1->CreateLocalEndpointHandle(kPrimaryInterfaceId), &paddle1,
-      nullptr, false, base::ThreadTaskRunnerHandle::Get(), 0u,
-      kTestInterfaceName, MessageToMethodInfo, MessageToMethodName);
+      nullptr, {}, base::ThreadTaskRunnerHandle::Get(), 0u, kTestInterfaceName,
+      MessageToMethodInfo, MessageToMethodName);
 
   paddle0.set_sender(&client0);
   paddle1.set_sender(&client1);
@@ -264,8 +264,8 @@
   CounterReceiver receiver;
   InterfaceEndpointClient client(
       router->CreateLocalEndpointHandle(kPrimaryInterfaceId), &receiver,
-      nullptr, false, base::ThreadTaskRunnerHandle::Get(), 0u,
-      kTestInterfaceName, MessageToMethodInfo, MessageToMethodName);
+      nullptr, {}, base::ThreadTaskRunnerHandle::Get(), 0u, kTestInterfaceName,
+      MessageToMethodInfo, MessageToMethodName);
 
   static const uint32_t kIterations[] = {1000, 3000000};
 
diff --git a/mojo/public/cpp/bindings/tests/multiplex_router_unittest.cc b/mojo/public/cpp/bindings/tests/multiplex_router_unittest.cc
index 59e3221..f6f99399 100644
--- a/mojo/public/cpp/bindings/tests/multiplex_router_unittest.cc
+++ b/mojo/public/cpp/bindings/tests/multiplex_router_unittest.cc
@@ -74,13 +74,13 @@
 
 TEST_F(MultiplexRouterTest, BasicRequestResponse) {
   InterfaceEndpointClient client0(
-      std::move(endpoint0_), nullptr, std::make_unique<PassThroughFilter>(),
-      false, base::ThreadTaskRunnerHandle::Get(), 0u, kTestInterfaceName,
+      std::move(endpoint0_), nullptr, std::make_unique<PassThroughFilter>(), {},
+      base::ThreadTaskRunnerHandle::Get(), 0u, kTestInterfaceName,
       MessageToMethodInfo, MessageToMethodName);
   ResponseGenerator generator;
   InterfaceEndpointClient client1(
       std::move(endpoint1_), &generator, std::make_unique<PassThroughFilter>(),
-      false, base::ThreadTaskRunnerHandle::Get(), 0u, kTestInterfaceName,
+      {}, base::ThreadTaskRunnerHandle::Get(), 0u, kTestInterfaceName,
       MessageToMethodInfo, MessageToMethodName);
 
   Message request;
@@ -123,13 +123,13 @@
 
 TEST_F(MultiplexRouterTest, BasicRequestResponse_Synchronous) {
   InterfaceEndpointClient client0(
-      std::move(endpoint0_), nullptr, std::make_unique<PassThroughFilter>(),
-      false, base::ThreadTaskRunnerHandle::Get(), 0u, kTestInterfaceName,
+      std::move(endpoint0_), nullptr, std::make_unique<PassThroughFilter>(), {},
+      base::ThreadTaskRunnerHandle::Get(), 0u, kTestInterfaceName,
       MessageToMethodInfo, MessageToMethodName);
   ResponseGenerator generator;
   InterfaceEndpointClient client1(
       std::move(endpoint1_), &generator, std::make_unique<PassThroughFilter>(),
-      false, base::ThreadTaskRunnerHandle::Get(), 0u, kTestInterfaceName,
+      {}, base::ThreadTaskRunnerHandle::Get(), 0u, kTestInterfaceName,
       MessageToMethodInfo, MessageToMethodName);
 
   Message request;
@@ -173,14 +173,14 @@
 TEST_F(MultiplexRouterTest, LazyResponses) {
   InterfaceEndpointClient client0(
       std::move(endpoint0_), nullptr, base::WrapUnique(new PassThroughFilter()),
-      false, base::ThreadTaskRunnerHandle::Get(), 0u, kTestInterfaceName,
+      {}, base::ThreadTaskRunnerHandle::Get(), 0u, kTestInterfaceName,
       MessageToMethodInfo, MessageToMethodName);
   base::RunLoop run_loop;
   LazyResponseGenerator generator(run_loop.QuitClosure());
   InterfaceEndpointClient client1(std::move(endpoint1_), &generator,
-                                  base::WrapUnique(new PassThroughFilter()),
-                                  false, base::ThreadTaskRunnerHandle::Get(),
-                                  0u, kTestInterfaceName, MessageToMethodInfo,
+                                  base::WrapUnique(new PassThroughFilter()), {},
+                                  base::ThreadTaskRunnerHandle::Get(), 0u,
+                                  kTestInterfaceName, MessageToMethodInfo,
                                   MessageToMethodName);
 
   Message request;
@@ -247,7 +247,7 @@
   base::RunLoop run_loop0, run_loop1;
   InterfaceEndpointClient client0(
       std::move(endpoint0_), nullptr, base::WrapUnique(new PassThroughFilter()),
-      false, base::ThreadTaskRunnerHandle::Get(), 0u, kTestInterfaceName,
+      {}, base::ThreadTaskRunnerHandle::Get(), 0u, kTestInterfaceName,
       MessageToMethodInfo, MessageToMethodName);
   bool error_handler_called0 = false;
   client0.set_connection_error_handler(base::BindOnce(
@@ -256,9 +256,9 @@
   base::RunLoop run_loop3;
   LazyResponseGenerator generator(run_loop3.QuitClosure());
   InterfaceEndpointClient client1(std::move(endpoint1_), &generator,
-                                  base::WrapUnique(new PassThroughFilter()),
-                                  false, base::ThreadTaskRunnerHandle::Get(),
-                                  0u, kTestInterfaceName, MessageToMethodInfo,
+                                  base::WrapUnique(new PassThroughFilter()), {},
+                                  base::ThreadTaskRunnerHandle::Get(), 0u,
+                                  kTestInterfaceName, MessageToMethodInfo,
                                   MessageToMethodName);
   bool error_handler_called1 = false;
   client1.set_connection_error_handler(base::BindOnce(
@@ -306,12 +306,12 @@
   {
     InterfaceEndpointClient client0(
         std::move(endpoint0_), nullptr, std::make_unique<PassThroughFilter>(),
-        false, base::ThreadTaskRunnerHandle::Get(), 0u, kTestInterfaceName,
+        {}, base::ThreadTaskRunnerHandle::Get(), 0u, kTestInterfaceName,
         MessageToMethodInfo, MessageToMethodName);
     InterfaceEndpointClient client1(std::move(endpoint1_), &generator,
-                                    std::make_unique<PassThroughFilter>(),
-                                    false, base::ThreadTaskRunnerHandle::Get(),
-                                    0u, kTestInterfaceName, MessageToMethodInfo,
+                                    std::make_unique<PassThroughFilter>(), {},
+                                    base::ThreadTaskRunnerHandle::Get(), 0u,
+                                    kTestInterfaceName, MessageToMethodInfo,
                                     MessageToMethodName);
 
     Message request;
diff --git a/mojo/public/cpp/bindings/tests/sync_method_unittest.cc b/mojo/public/cpp/bindings/tests/sync_method_unittest.cc
index b27a0449..7649960 100644
--- a/mojo/public/cpp/bindings/tests/sync_method_unittest.cc
+++ b/mojo/public/cpp/bindings/tests/sync_method_unittest.cc
@@ -2,6 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <tuple>
 #include <utility>
 
 #include "base/barrier_closure.h"
@@ -9,15 +10,21 @@
 #include "base/check.h"
 #include "base/run_loop.h"
 #include "base/sequence_token.h"
+#include "base/task/sequenced_task_runner.h"
 #include "base/task/thread_pool.h"
 #include "base/test/bind.h"
 #include "base/test/task_environment.h"
 #include "base/threading/sequence_bound.h"
+#include "base/threading/sequenced_task_runner_handle.h"
 #include "base/threading/thread.h"
 #include "base/time/time.h"
 #include "mojo/public/cpp/bindings/associated_receiver.h"
 #include "mojo/public/cpp/bindings/associated_receiver_set.h"
 #include "mojo/public/cpp/bindings/associated_remote.h"
+#include "mojo/public/cpp/bindings/lib/message_fragment.h"
+#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
+#include "mojo/public/cpp/bindings/lib/serialization_util.h"
+#include "mojo/public/cpp/bindings/message.h"
 #include "mojo/public/cpp/bindings/receiver.h"
 #include "mojo/public/cpp/bindings/receiver_set.h"
 #include "mojo/public/cpp/bindings/remote.h"
@@ -27,10 +34,16 @@
 #include "mojo/public/cpp/bindings/shared_remote.h"
 #include "mojo/public/cpp/bindings/sync_call_restrictions.h"
 #include "mojo/public/cpp/bindings/tests/bindings_test_base.h"
+#include "mojo/public/cpp/bindings/tests/sync_method_unittest.test-mojom-shared-message-ids.h"
 #include "mojo/public/cpp/bindings/tests/sync_method_unittest.test-mojom.h"
 #include "mojo/public/interfaces/bindings/tests/test_sync_methods.mojom.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
+// This needs to be included last, since it forward declares a bunch of classes
+// but depends on those definitions to be included by headers that sort
+// lexicographically after.
+#include "mojo/public/cpp/bindings/tests/sync_method_unittest.test-mojom-params-data.h"
+
 namespace mojo {
 namespace test {
 namespace sync_method_unittest {
@@ -1703,6 +1716,237 @@
 INSTANTIATE_MOJO_BINDINGS_TEST_SUITE_P(SyncInterruptTest);
 INSTANTIATE_MOJO_BINDINGS_TEST_SUITE_P(DisableSyncInterruptTest);
 
+class OneSyncImpl;
+
+class NoSyncImpl : public mojom::NoSync {
+ public:
+  explicit NoSyncImpl(PendingReceiver<mojom::NoSync> receiver)
+      : receiver_(this, std::move(receiver)) {}
+
+  explicit NoSyncImpl(
+      PendingAssociatedReceiver<mojom::NoSync> associated_receiver)
+      : associated_receiver_(this, std::move(associated_receiver)) {}
+
+  // mojom::NoSync implementation:
+  void Method(MethodCallback callback) override;
+  void BindNoSync(PendingAssociatedReceiver<mojom::NoSync> receiver) override;
+  void BindOneSync(PendingAssociatedReceiver<mojom::OneSync> receiver) override;
+
+ private:
+  Receiver<mojom::NoSync> receiver_{this};
+  AssociatedReceiver<mojom::NoSync> associated_receiver_{this};
+
+  std::unique_ptr<NoSyncImpl> associated_no_sync_;
+  std::unique_ptr<OneSyncImpl> associated_one_sync_;
+};
+
+class OneSyncImpl : public mojom::OneSync {
+ public:
+  explicit OneSyncImpl(PendingReceiver<mojom::OneSync> receiver)
+      : receiver_(this, std::move(receiver)) {}
+
+  explicit OneSyncImpl(
+      PendingAssociatedReceiver<mojom::OneSync> associated_receiver)
+      : associated_receiver_(this, std::move(associated_receiver)) {}
+
+  // mojom::OneSync implementation:
+  void Method(MethodCallback callback) override;
+  void SyncMethod(SyncMethodCallback callback) override;
+  void BindNoSync(PendingAssociatedReceiver<mojom::NoSync> receiver) override;
+  void BindOneSync(PendingAssociatedReceiver<mojom::OneSync> receiver) override;
+
+ private:
+  Receiver<mojom::OneSync> receiver_{this};
+  AssociatedReceiver<mojom::OneSync> associated_receiver_{this};
+
+  std::unique_ptr<NoSyncImpl> associated_no_sync_;
+  std::unique_ptr<OneSyncImpl> associated_one_sync_;
+};
+
+void NoSyncImpl::Method(MethodCallback callback) {
+  EXPECT_TRUE(false);
+  std::move(callback).Run();
+}
+
+void NoSyncImpl::BindNoSync(PendingAssociatedReceiver<mojom::NoSync> receiver) {
+  associated_no_sync_ = std::make_unique<NoSyncImpl>(std::move(receiver));
+}
+
+void NoSyncImpl::BindOneSync(
+    PendingAssociatedReceiver<mojom::OneSync> receiver) {
+  associated_one_sync_ = std::make_unique<OneSyncImpl>(std::move(receiver));
+}
+
+void OneSyncImpl::Method(MethodCallback callback) {
+  EXPECT_TRUE(false);
+  std::move(callback).Run();
+}
+
+void OneSyncImpl::SyncMethod(MethodCallback callback) {
+  std::move(callback).Run();
+}
+
+void OneSyncImpl::BindNoSync(
+    PendingAssociatedReceiver<mojom::NoSync> receiver) {
+  associated_no_sync_ = std::make_unique<NoSyncImpl>(std::move(receiver));
+}
+
+void OneSyncImpl::BindOneSync(
+    PendingAssociatedReceiver<mojom::OneSync> receiver) {
+  associated_one_sync_ = std::make_unique<OneSyncImpl>(std::move(receiver));
+}
+
+class NoResponseExpectedResponder : public MessageReceiver {
+ public:
+  explicit NoResponseExpectedResponder() = default;
+
+  // MessageReceiver implementation:
+  bool Accept(Message* message) override {
+    EXPECT_TRUE(false);
+    return true;
+  }
+};
+
+class SyncFlagValidationTest : public ::testing::TestWithParam<uint32_t> {
+ protected:
+  Message MakeNoSyncMethodMessage() {
+    const uint32_t flags =
+        // Always set the sync flag, as that's the primary point of the test.
+        Message::kFlagIsSync |
+        // InterfaceEndpointClient requires this flag if sending a message with
+        // a responder.
+        Message::kFlagExpectsResponse | GetParam();
+    Message message(mojom::internal::kNoSync_Method_Name, flags, 0, 0, nullptr);
+    ::mojo::internal::MessageFragment<
+        mojom::internal::NoSync_Method_Params_Data>
+        params(message);
+    params.Allocate();
+    return message;
+  }
+
+  Message MakeOneSyncMethodMessage() {
+    const uint32_t flags =
+        // Always set the sync flag, as that's the primary point of the test.
+        Message::kFlagIsSync |
+        // InterfaceEndpointClient requires this flag if sending a message with
+        // a responder.
+        Message::kFlagExpectsResponse | GetParam();
+    Message message(mojom::internal::kOneSync_Method_Name, flags, 0, 0,
+                    nullptr);
+    ::mojo::internal::MessageFragment<
+        mojom::internal::NoSync_Method_Params_Data>
+        params(message);
+    params.Allocate();
+    return message;
+  }
+
+  void FlushPostedTasks() {
+    base::RunLoop run_loop;
+    base::SequencedTaskRunnerHandle::Get()->PostTask(FROM_HERE,
+                                                     run_loop.QuitClosure());
+    run_loop.Run();
+  }
+
+ private:
+  base::test::SingleThreadTaskEnvironment task_environment;
+};
+
+TEST_P(SyncFlagValidationTest, NonSync) {
+  Remote<mojom::NoSync> remote;
+  NoSyncImpl impl(remote.BindNewPipeAndPassReceiver());
+
+  Message message = MakeNoSyncMethodMessage();
+  auto responder = std::make_unique<NoResponseExpectedResponder>();
+  ASSERT_TRUE(remote.internal_state()->endpoint_client_for_test());
+  ::mojo::internal::SendMojoMessage(
+      *remote.internal_state()->endpoint_client_for_test(), message,
+      std::move(responder));
+}
+
+TEST_P(SyncFlagValidationTest, OneSync) {
+  Remote<mojom::OneSync> remote;
+  OneSyncImpl impl(remote.BindNewPipeAndPassReceiver());
+
+  Message message = MakeOneSyncMethodMessage();
+  auto responder = std::make_unique<NoResponseExpectedResponder>();
+  ASSERT_TRUE(remote.internal_state()->endpoint_client_for_test());
+  ::mojo::internal::SendMojoMessage(
+      *remote.internal_state()->endpoint_client_for_test(), message,
+      std::move(responder));
+}
+
+TEST_P(SyncFlagValidationTest, NoSyncAssociatedWithNoSync) {
+  Remote<mojom::NoSync> remote;
+  NoSyncImpl impl(remote.BindNewPipeAndPassReceiver());
+
+  AssociatedRemote<mojom::NoSync> associated_remote;
+  remote->BindNoSync(associated_remote.BindNewEndpointAndPassReceiver());
+
+  FlushPostedTasks();
+
+  Message message = MakeNoSyncMethodMessage();
+  auto responder = std::make_unique<NoResponseExpectedResponder>();
+  ASSERT_TRUE(remote.internal_state()->endpoint_client_for_test());
+  ::mojo::internal::SendMojoMessage(
+      *associated_remote.internal_state()->endpoint_client_for_test(), message,
+      std::move(responder));
+}
+
+TEST_P(SyncFlagValidationTest, OneSyncAssociatedWithNoSync) {
+  Remote<mojom::NoSync> remote;
+  NoSyncImpl impl(remote.BindNewPipeAndPassReceiver());
+
+  AssociatedRemote<mojom::OneSync> associated_remote;
+  remote->BindOneSync(associated_remote.BindNewEndpointAndPassReceiver());
+
+  FlushPostedTasks();
+
+  Message message = MakeOneSyncMethodMessage();
+  auto responder = std::make_unique<NoResponseExpectedResponder>();
+  ASSERT_TRUE(remote.internal_state()->endpoint_client_for_test());
+  ::mojo::internal::SendMojoMessage(
+      *associated_remote.internal_state()->endpoint_client_for_test(), message,
+      std::move(responder));
+}
+
+TEST_P(SyncFlagValidationTest, NoSyncAssociatedWithOneSync) {
+  Remote<mojom::OneSync> remote;
+  OneSyncImpl impl(remote.BindNewPipeAndPassReceiver());
+
+  AssociatedRemote<mojom::NoSync> associated_remote;
+  remote->BindNoSync(associated_remote.BindNewEndpointAndPassReceiver());
+
+  FlushPostedTasks();
+
+  Message message = MakeNoSyncMethodMessage();
+  auto responder = std::make_unique<NoResponseExpectedResponder>();
+  ASSERT_TRUE(remote.internal_state()->endpoint_client_for_test());
+  ::mojo::internal::SendMojoMessage(
+      *associated_remote.internal_state()->endpoint_client_for_test(), message,
+      std::move(responder));
+}
+
+TEST_P(SyncFlagValidationTest, OneSyncAssociatedWithOneSync) {
+  Remote<mojom::OneSync> remote;
+  OneSyncImpl impl(remote.BindNewPipeAndPassReceiver());
+
+  AssociatedRemote<mojom::OneSync> associated_remote;
+  remote->BindOneSync(associated_remote.BindNewEndpointAndPassReceiver());
+
+  FlushPostedTasks();
+
+  Message message = MakeOneSyncMethodMessage();
+  auto responder = std::make_unique<NoResponseExpectedResponder>();
+  ASSERT_TRUE(remote.internal_state()->endpoint_client_for_test());
+  ::mojo::internal::SendMojoMessage(
+      *associated_remote.internal_state()->endpoint_client_for_test(), message,
+      std::move(responder));
+}
+
+INSTANTIATE_TEST_SUITE_P(,
+                         SyncFlagValidationTest,
+                         ::testing::Values(0, Message::kFlagIsResponse));
+
 }  // namespace
 }  // namespace sync_method_unittest
 }  // namespace test
diff --git a/mojo/public/cpp/bindings/tests/sync_method_unittest.test-mojom b/mojo/public/cpp/bindings/tests/sync_method_unittest.test-mojom
index 9f08b53..85104fb 100644
--- a/mojo/public/cpp/bindings/tests/sync_method_unittest.test-mojom
+++ b/mojo/public/cpp/bindings/tests/sync_method_unittest.test-mojom
@@ -49,3 +49,20 @@
 interface SyncService {
   [Sync] SyncCall() => ();
 };
+
+interface NoSync {
+  Method() => ();
+
+  BindNoSync(pending_associated_receiver<NoSync> no_sync);
+  BindOneSync(pending_associated_receiver<OneSync> one_sync);
+};
+
+interface OneSync {
+  Method() => ();
+
+  [Sync]
+  SyncMethod() => ();
+
+  BindNoSync(pending_associated_receiver<NoSync> no_sync);
+  BindOneSync(pending_associated_receiver<OneSync> one_sync);
+};
diff --git a/mojo/public/tools/bindings/generators/cpp_templates/interface_declaration.tmpl b/mojo/public/tools/bindings/generators/cpp_templates/interface_declaration.tmpl
index c53d4ea..6e02107b 100644
--- a/mojo/public/tools/bindings/generators/cpp_templates/interface_declaration.tmpl
+++ b/mojo/public/tools/bindings/generators/cpp_templates/interface_declaration.tmpl
@@ -32,7 +32,12 @@
 {%- endif %}
   static constexpr uint32_t Version_ = {{interface.version}};
   static constexpr bool PassesAssociatedKinds_ = {% if interface|passes_associated_kinds %}true{% else %}false{% endif %};
-  static constexpr bool HasSyncMethods_ = {% if interface|has_sync_methods %}true{% else %}false{% endif %};
+{%- set sync_method_ordinals = interface|get_sync_method_ordinals -%}
+{%- if sync_method_ordinals %}
+  static inline constexpr uint32_t kSyncMethodOrdinals[] = {
+    {{sync_method_ordinals|sort|join(', \n')|indent(4)}}
+  };
+{%- endif %}
   static constexpr bool HasUninterruptableMethods_ =
       {%- if interface|has_uninterruptable_methods %} true
       {%- else %} false{% endif %};
diff --git a/mojo/public/tools/bindings/generators/cpp_templates/module-params-data.h.tmpl b/mojo/public/tools/bindings/generators/cpp_templates/module-params-data.h.tmpl
index e60288b..d1688f1 100644
--- a/mojo/public/tools/bindings/generators/cpp_templates/module-params-data.h.tmpl
+++ b/mojo/public/tools/bindings/generators/cpp_templates/module-params-data.h.tmpl
@@ -17,13 +17,15 @@
 #pragma clang diagnostic ignored "-Wunused-private-field"
 #endif
 
+namespace mojo::internal {
+class ValidationContext;
+}
+
 {%- for namespace in namespaces_as_array %}
 namespace {{namespace}} {
 {%- endfor %}
 namespace internal {
 
-class ValidationContext;
-
 {#--- Interface parameter definitions #}
 {%- for interface in interfaces %}
 {%-   for method in interface.methods %}
diff --git a/mojo/public/tools/bindings/generators/mojom_cpp_generator.py b/mojo/public/tools/bindings/generators/mojom_cpp_generator.py
index a4b51f7d..316b4da 100644
--- a/mojo/public/tools/bindings/generators/mojom_cpp_generator.py
+++ b/mojo/public/tools/bindings/generators/mojom_cpp_generator.py
@@ -403,7 +403,7 @@
         "get_qualified_name_for_kind": self._GetQualifiedNameForKind,
         "has_callbacks": mojom.HasCallbacks,
         "has_packed_method_ordinals": HasPackedMethodOrdinals,
-        "has_sync_methods": mojom.HasSyncMethods,
+        "get_sync_method_ordinals": mojom.GetSyncMethodOrdinals,
         "has_uninterruptable_methods": mojom.HasUninterruptableMethods,
         "method_supports_lazy_serialization":
         self._MethodSupportsLazySerialization,
diff --git a/mojo/public/tools/mojom/mojom/generate/module.py b/mojo/public/tools/mojom/mojom/generate/module.py
index 8b5d14f..27710ad 100644
--- a/mojo/public/tools/mojom/mojom/generate/module.py
+++ b/mojo/public/tools/mojom/mojom/generate/module.py
@@ -1729,11 +1729,8 @@
   return _AnyMethodParameterRecursive(method, IsInterfaceKind)
 
 
-def HasSyncMethods(interface):
-  for method in interface.methods:
-    if method.sync:
-      return True
-  return False
+def GetSyncMethodOrdinals(interface):
+  return [method.ordinal for method in interface.methods if method.sync]
 
 
 def HasUninterruptableMethods(interface):
